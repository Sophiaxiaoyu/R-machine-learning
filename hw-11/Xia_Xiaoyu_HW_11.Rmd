---
title: "INFSCI 2595 Spring 2023 Homework: 11"
subtitle: "Assigned April 12, 2023; Due: April 19, 2023"
author: "Xiaoyu Xia"
date: "Submission time: April 19, 2023 at 11:00PM EST"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#### Collaborators

Include the names of your collaborators here.  

## Overview

This homework begins by reviewing linear separability and why it causes issues for logistic regression models. The bulk of the assignment is dedicated to comparing binary classification models. You will train unregularized and regularized logistic regression models, neural networks, random forests, and gradient boosted trees with XGBoost.  

You will use the `tidyverse`, `glmnet`, `randomForest`, `xgboost`, and `caret` packages in this assignment. The `caret` package will prompt you to install `xgboost` if you do not have it installed already.  

**IMPORTANT**: The RMarkdown assumes you have downloaded the data sets (CSV files) to the same directory you saved the template Rmarkdown file. If you do not have the CSV files in the correct location, the data will not be loaded correctly.  

### IMPORTANT!!!

Certain code chunks are created for you. Each code chunk has `eval=FALSE` set in the chunk options. You **MUST** change it to be `eval=TRUE` in order for the code chunks to be evaluated when rendering the document.  

You are free to add more code chunks if you would like.  

## Load packages

This assignment will use packages from the `tidyverse` suite.  

```{r, load_packages}
library(tidyverse)
```

This assignment also uses the `broom` package. The `broom` package is part of `tidyverse` and so you have it installed already. The `broom` package will be used via the `::` operator later in the assignment and so you do not need to load it directly.  

The `caret` package will be loaded later in the assignment. The `glmnet`, `randomForest`, and `xgboost` packages will be loaded via `caret`.  

## Problem 01

The code chunk below loads the data you will work with in this assignment. The data consists of 3 inputs, `x1`, `x2` and `x3`, and one binary outcome, `y`. The `x1` and `x2` inputs are continuous while the `x3` input is categorical.  

```{r, read_data}
df <- readr::read_csv('hw11_binary_train.csv', col_names = TRUE)
```

The glimpse shows the data types of the 4 variables and that there are 300 rows in the data set.  

```{r, show_data_glimpse}
df %>% glimpse()
```

However, you will begin this assignment by working with a very small subset of the data. The small subset is created for you below. This small data set is created strictly to reinforce an important concept associated with logistic regression. You should **not** perform an operation like this in the final project. Again, this procedure is performed here for teaching purposes.  

```{r, make_small_data}
df_small <- df %>% slice(1:21)

df_small
```

The small data, `df_small`, consists of a single value for the categorical variable `x3`, as shown below.  

```{r, check_x3_counts_small}
df_small %>% count(x3)
```

The larger data set, which you will work with later, has 3 balanced unique values (categories or *levels*):  

```{r, check_x3_counts}
df %>% count(x3)
```

The binary outcome, `y`, is encoded as `y = 1` for the EVENT and `y = 0` for the NON-EVENT. The counts and proportions associated with the 2 unique value values of `y` are shown below for the small data set:  

```{r, check_y_counts_small}
df_small %>% count(y) %>% 
  mutate(prop = n / sum(n))
```

The counts and proportions associated with `y` on the larger data set are provided below.  

```{r, check_y_counts}
df %>% count(y) %>% 
  mutate(prop = n / sum(n))
```

Problem 01 deals with the small data set while the other problems are focused on the original larger data. The small data, `df_small`, corresponds to a single categorical value, `x3 = 'A'`, and thus you will focus on the relationship between the binary outcome, `y`, and the continuous inputs, `x1`, and `x2`, in Problem 01.  


### 1a)

Let's start with a simple exploration of the **small** data, `df_small`.  

**Create scatter plots to show the relationship between the binary outcome `y` and the continuous inputs `x1` and `x2`. You may create two figures or reshape the data to long-format to support creating one figure with two facets.**  

#### SOLUTION
```{r}
df_small %>%
  pivot_longer(cols = c("x1", "x2"), names_to = "Variable", values_to = "Value") %>%
  ggplot(aes(x = Value, y = y)) +
  geom_point(size = 4) +
  facet_wrap(~Variable, scales = "free_x")
```
### 1b)

**Based on the relationships presented in 1a), do you feel you should be concerned about linear separability in this problem?**  

#### SOLUTION

What do you think?  
The problem may not be linearly separable.Based on the scatter plots, it seems that the relationship between the binary outcome y and the continuous input variables x1 and x2 is not very clear. 

### 1c)

Let's fit a non-Bayesian logistic regression model to see if your answer in 1b) was correct!  

**Fit a non-Bayesian logistic regression model to predict the binary outcome `y` based on the two continuous inputs, `x1` and `x2`. Your model must include the linear main effects and the interaction between the two continuous inputs.**  

**Assign the model to the `mod_small_a` variable.**  

*HINT*: Be careful with the `family` argument!  

#### SOLUTION

```{r}
mod_small_a <- glm( y ~ x1 * x2, df_small,family = 'binomial' )
```

### 1d)

Let's now fit a more complicated logistic regression model. Let's include quadratic features for both `x1` and `x2`.  

**Fit a non-Bayesian logistic regression model using linear main effects, interactions between the two continuous inputs, and quadratic features associated with both continuous inputs.**  

**Assign he model to the `mod_small_b` variable.**  

#### SOLUTION
```{r}
mod_small_b <- glm( y ~ x1 * x2 + I(x1^2) + I(x2^2), df_small,family = 'binomial' )
```
  

### 1e)

Something might seem suspicious about the result from the model in 1d)...  

**Display the `summary()` of the `mod_small_b` model to the screen. Do you notice anything "extreme" about about any of the coefficient MLEs?**  

#### SOLUTION
```{r}
summary(mod_small_b)
```


What do you think?  

The warning message "glm.fit: fitted probabilities numerically 0 or 1 occurred" means that the model is overfitting the data and may not be a good fit. This is likely due to the inclusion of quadratic terms in the model.

Including quadratic terms in logistic regression can sometimes cause numerical issues when fitting the model, especially when the data is not well-separated. In this case, since the scatter plots suggested that the data is not linearly separable, it is possible that the inclusion of quadratic terms is causing the model to fit the noise in the data, rather than the underlying pattern.

### 1f)

You visualized the relationship between the binary outcome, `y`, and each continuous input in 1a). However, you did not examine the behavior of `y` with respect to **both** inputs at the same time. The binary outcome can be mapped to the marker `color` and `shape` aesthetics in scatter plots between continuous inputs. Such figures allow visually identifying regions of the *joint* input space where the event occurs more frequently than other regions. Let's create such a plot to understand what happened with `mod_small_b`.  

**Create a scatter plot showing the relationship between the two continuous inputs. You should map the `x1` variable to the `x` aesthetic and the `x2` variable to the `y` aesthetic. Map the `color` and `shape` aesthetics to `as.factor(y)` within the appropriate geom function. Manually assign the marker `size` to be 5.**  

*HINT*: Do NOT use `geom_jitter()`.  

#### SOLUTION
```{r}
ggplot(df_small, mapping =aes(x = x1, y = x2, color = as.factor(y), shape = as.factor(y))) +
  geom_point(size = 5)
```


### 1g)

**Why does the figure in 1f) explain the behavior of `mod_small_b`?**  

#### SOLUTION

What do you think?  
The scatter plot with y mapped to both the color and shape aesthetics allows us to visualize the relationship between x1, x2, and y. In this plot, we can see that the data is not linearly separable, meaning that we cannot draw a straight line to perfectly separate the two classes (indicated by the colors and shapes) from each other. Instead, we see that the two classes overlap in the middle region of the plot.

This explains why mod_small_b, which included only linear and quadratic terms of x1 and x2, was not able to fit the data well. It is not flexible enough to capture the non-linear relationship between the inputs and the output. As a result, the model was forced to assign predicted probabilities of 0 or 1 to some observations, leading to the warning message that "fitted probabilities numerically 0 or 1 occurred".



## Problem 02

The remainder of the assignment will use the larger `df` data set.  

### 2a)

It would be best to perform a full visual exploration of the data, but you will focus on the binary outcome, `y`, to continuous input relationships in this assignment. (A full exploration includes marginal distributions and conditional distributions of the variables and also examining the relationships between the inputs.)  

**Create scatter plots to show the relationship between the binary outcome `y` and the continuous inputs `x1` and `x2`. You may create two figures or reshape the data to long-format to support creating one figure with two facets.**  

#### SOLUTION

```{r}
df%>%
  pivot_longer(cols = c("x1", "x2"), names_to = "Variable", values_to = "Value") %>%
  ggplot(aes(x = Value, y = y)) +
  geom_point() +
  facet_wrap(~Variable, scales = "free_x")
```
  

### 2b)

Let's now consider the relationship between the binary outcome and the *joint* behavior of the continuous inputs.  

**Create a scatter plot showing the relationship between the two continuous inputs. You should map the `x1` variable to the `x` aesthetic and the `x2` variable to the `y` aesthetic. Map the `color` and `shape` aesthetics to `as.factor(y)` within the appropriate geom function. Manually assign the marker `size` to be 3.**  

*HINT*: Do NOT use `geom_jitter()`.  

This figure is similar to the figure in 1f) but you are using the larger data set, `df`.  

#### SOLUTION
```{r}
ggplot(df, mapping =aes(x = x1, y = x2, color = as.factor(y), shape = as.factor(y))) +
  geom_point(size = 3)
```


### 2c)

Let's now include the effect of the categorical input!  

**Create the same scatter plot as 2b), but this time include facets based on the categorical input `x3`. You must still use the marker `color` and `shape` aesthetics to denote the binary outcome.**  

#### SOLUTION
```{r}
ggplot(df, mapping=aes(x = x1, y = x2, color = as.factor(y), shape = as.factor(y))) +
  geom_point(size = 3) +
  facet_wrap(~x3)
```


### 2d)

**How would you describe the behavior of the binary outcome relative to the 3 inputs, based on the figure created in 2c)?**  

#### SOLUTION

What do you think?  
Based on the scatter plot, we can observe that when x3 is equal to 'A', the events with y=1 are located in the center of the continuous input space, and the non-events with y=0 surround them, but there is some overlap between the two. On the other hand, the events appear to be associated with both continuous inputs increasing together when x3='B', while the events are associated with an anti-relationship between the two continuous inputs when x3='C'. In summary, we can conclude that the behavior of the binary outcome relative to the three inputs is complex and varies depending on the value of x3.

## Problem 03

You fit multiple logistic regression models ranging from simple to complex in the previous assignment. That is the best way to go about a modeling exercise because it allows us to learn the kinds of features required to improve model behavior. We are able to build a "story" about what it takes to predict the output!  

However, we will just fit a single logistic regression model in this assignment. This model is relatively complex. We are "short cutting" the modeling workflow so we can focus on predictions. Later in the assignment, we will use the elastic net penalty to try to turn the complex model into a simpler model.  

### 3a)

**Fit a non-Bayesian logistic regression model which interacts the categorical input with all linear main effects, interactions between the two continuous inputs, and quadratic features associated with both continuous inputs. Thus, ALL features derived from the continuous inputs must interact with the categorical variable.**  

**Assign the model to the `fit_glm` variable.**  

*HINT*: Be careful with the `family` argument!  

#### SOLUTION

```{r}
fit_glm <- glm( y ~ x3 * (x1*x2 + I(x1^2) + I(x2^2)), df, family = 'binomial' )
```


### 3b)

**Are the interaction features considered statistically significant according to the non-Bayesian logistic regression model?**  

#### SOLUTION
```{r}
summary(fit_glm)
```


What do you think?  
The interaction features are considered statistically significant according to the non-Bayesian logistic regression model.

### 3c)

Examining the coefficients is one way to try to interpret model behavior. However, we can also use predictions to visualize the relationships. This is especially helpful with binary classification problems because it allows us to visually identify regions of low event probability vs regions of high event probability.  

The code chunk below defines an input visualization grid for you. It is a full factorial grid between the 3 inputs. We will focus on the patterns relative to the continuous inputs, which is why there are 75 unique values for each input. The 75 x 75 input grid is repeated for each unique value of the categorical input. Thus, there are 16875 input combinations in the visualization grid. You must make 16875 predictions to study the model behavior!  

```{r, make_input_viz_grid}
viz_grid <- expand.grid(x1 = seq(-3, 3, length.out=75),
                        x2 = seq(-3, 3, length.out=75),
                        x3 = c("A", "B", "C"),
                        KEEP.OUT.ATTRS = FALSE, 
                        stringsAsFactors = FALSE) %>% 
  as.data.frame() %>% tibble::as_tibble()

viz_grid %>% glimpse()
```

You should have fit the logistic regression model with the `glm()` function. Predictions from `glm()` fit objects are made with the `predict()` function, just like `lm()` fit models. However, *generalized* linear models make predictions for the **linear predictor** as well as the **mean output trend**. Therefore, we need to make sure we are making the predictions of the correct type of variable!  

You will first make predictions with the `fit_glm` model using the default arguments to `predict()`.  

**Predict the input visualization grid with the `fit_glm` model. The first argument to `predict()` is the model. The second argument is `newdata` and should be named in the `predict()` function call. Assign the `viz_grid` object to the `newdata` argument to ensure the input visualization grid is predicted.**  

**Assign the result to the `pred_viz_glm_a` variable and display the `summary()` of the `pred_viz_glm_a` to the screen.**  

#### SOLUTION
```{r}
pred_viz_glm_a <- predict(fit_glm, newdata = viz_grid)
summary(pred_viz_glm_a)
```
 

### 3d)

The `predict()` function has additional arguments which control how the predictions are made. You will make predictions again, but this time you must include a third argument, `type`, in the `predict()` function call. You must set `type = 'response'` in the `predict()` call.  

**Predict the input visualization grid with the `fit_glm` model again. Use the same two arguments as in 3c) but this time include the third argument `type` with the value assigned to `'response'`.**  

**Assign the result to the `pred_viz_glm_b` variable and display the `summary()` of the `pred_viz_glm_b` to the screen.**  

#### SOLUTION
```{r}
pred_viz_glm_b <- predict(fit_glm, newdata = viz_grid, type = 'response')
summary(pred_viz_glm_b)
```


### 3e)
You made two types of predictions. One corresponds to the linear predictor while one corresponds to the output mean trend. The output mean is the **event probability** in logistic regression problems.  

**Which of the two predictions, `pred_viz_glm_a` or `pred_viz_glm_b`, corresponds to the event probability? How do you know based on the two previous results?**  

#### SOLUTION

What do you think?  
The prediction pred_viz_glm_b corresponds to the event probability. We know this because the type = 'response' argument was used when making the prediction, which specifies that we want the predicted probabilities of the event.
In addition, the region of the 'summary(pred_viz_glm_b)' shows the event probability from 0 to 1.

### 3f)

Let's now visualize the event probability surface with respect to the three inputs! You will made a *raster* plot to visualize the predicted probability surface with respect to the two continuous inputs faceted by the categorical variable. Raster plots will look like *images* and are possible when we have full factorial input grids.  

**Pipe the `viz_grid` dataframe to the `mutate()` function. Include the variable `mu` to the dataframe and assign the predicted probability to the `mu` variable. Pipe the result to `ggplot()` and map the `x1` and `x2` variables to the `x` and `y` aesthetics, respectively. Add a `geom_raster()` layer and map the `fill` aesthetic to the `mu` variable. Include facets via the `facet_wrap()` function with the facets "a function of `x3`". Lastly, specify the fill color palette via the `scale_fill_viridis_c()` function.**  

*HINT*: You identified which of the predictions corresponds to the event probability in 3e)!  

*HINT*: Don't forget about the importance of the `aes()` function!  

#### SOLUTION

```{r}
viz_grid %>% mutate(mu = pred_viz_glm_b) %>%
  ggplot(mapping=aes(x = x1, y = x2)) +
  geom_raster(mapping = aes(fill = mu)) +
  scale_fill_viridis_c()+
  facet_wrap(~x3)
```


### 3g)

The previous figure used a sequential color palette to represent the event probability. Low probabilities are dark blue while high probabilities are bright yellow within the viridis color palette. However, event probabilities have a natural *boundary* to focus on. We want to identify the 50% probability *decision boundary* because 0.5 is the common threshold for *classifying* events in predictions.  

We can represent the 50% decision boundary by using a *diverging* palette. The diverging palette focuses on behavior away from a central value. One color represents increasing values from the midpoint while another color represents decreasing values from the midpoint. Classification problems have a natural midpoint value of 0.5 and thus the diverging colors will represent probabilities increasing away from 50% and probabilities decreasing away from 50%. For this problem, you should use the following syntax to create the diverging palette:  

```{r, show_gradient2, eval=FALSE}
# do NOT set eval=TRUE in this code chunk!!!!
scale_fill_gradient2(low = 'blue', mid = 'white', high = 'red',
                     midpoint = 0.5,
                     limits = c(0, 1))
```

The syntax specifies that the midpoint is 0.5 while the limits are 0 and 1. Values decreasing from the midpoint are represented by blue colors, while values increasing away from the midpoint are represented by red colors. The midpoint value (0.5 in this case) corresponds to white. Thus, the 50% *decision boundary* will be represented by separating blue and red regions by a white boundary!  

**Create the same figure as in 3f) but this time replace `scale_fill_viridis_c()` with the diverging scale.**  

#### SOLUTION

```{r}
viz_grid %>% mutate(mu = pred_viz_glm_b) %>%
  ggplot(mapping=aes(x = x1, y = x2)) +
  geom_raster(mapping = aes(fill = mu)) +
  scale_fill_gradient2(low = 'blue', mid = 'white', high = 'red',
                     midpoint = 0.5,
                     limits = c(0, 1))+
  facet_wrap(~x3)
```
### 3h)

**What are the general shapes of the 50% decision boundary for your model? Does the boundary shape depend on the categorical variable?**  

#### SOLUTION

What do you think?  
The shape of the 50% decision boundary of the logistic regression model depends on the categorical variable x3. When x3 is 'A', the boundary is circular, which means that continuous input values inside the circle correspond to high event probabilities while those outside correspond to low probabilities. 
On the other hand, when x3 is 'B', the boundary looks like an ellipse pointing diagonally to the right.
When x3 is 'C', the boundary is oriented the other way, and the high probability region looks like a diagonal stripe, creating two low probability regions. 

## Problem 04

We fit a relatively complex model in the previous problem. Let's use regularization to see if a simpler model will improve performance. You will use non-Bayesian regularization in this assignment via the `glmnet` package. You will tune the elastic net's mixing fraction, `alpha`, and regularization strength, `lambda`, via the `caret::train()` function rather than using `glmnet` directly.  

The `caret` package is loaded for you in the code chunk below.  

```{r, load_caret_pkg}
library(caret)
```

The `caret` package prefers the binary outcome to be organized as a factor data type compared to an integer. The data set is reformatted for you in the code chunk below. The binary outcome `y` is converted to a new variable `outcome` with values `'event'` and `'non_event'`. The first level is forced to be `'event'` to be consistent with the `caret` preferred structure.  

```{r, make_caret_dataset}
df_caret <- df %>% 
  mutate(outcome = ifelse(y == 1, 'event', 'non_event')) %>% 
  mutate(outcome = factor(outcome, levels = c("event", "non_event"))) %>% 
  select(x1, x2, x3, outcome)

df_caret %>% glimpse()
```

### 4a)

You must always specify the resampling scheme and primary performance metric when using `caret`. You will use the same resampling as the previous assignment, 10 fold cross-validation with 3 repeats. You will also use the Accuracy as the primary performance metric.  

**Specify the resampling scheme to be 10 fold with 3 repeats. Assign the result of the `trainControl()` function to the `my_ctrl` object. Specify the primary performance metric to be `'Accuracy'` and assign that to the `my_metric` object.**  

#### SOLUTION
```{r}
my_ctrl <- trainControl(method = 'repeatedcv', number = 10, repeats = 3)
my_metric <- "Accuracy"
```


### 4b)

You must train, assess, and tune an elastic net model using the default `caret` tuning grid. In the `caret::train()` function you must use the formula interface to specify a model consistent with `fit_glm`. Your model must interact the categorical input with all linear main effects, interactions between the two continuous inputs, and quadratic features associated with both continuous inputs. Thus, ALL features derived from the continuous inputs must interact with the categorical variable. **Please pay close attention to your formula.** The binary outcome is now named `outcome` and **not** `y`.  Assign the method argument to `'glmnet'` and set the metric argument to `my_metric`. You **must** also instruct `caret` to standardize the features by setting the `preProcess` argument equal to `c('center', 'scale')`. This will give you practice standardizing inputs even though it is not critical for this particular application. Assign the `trControl` argument to the `my_ctrl` object.  

**Important**: The `caret::train()` function works with the formula interface. Thus, even though you are using `glmnet` to fit the model, `caret` does not require you to organize the design matrix as required by `glmnet`! Thus, you do **NOT** need to remove the intercept when defining the formula to `caret::train()`!  

**Train, assess, and tune the `glmnet` elastic net model with the defined resampling scheme. Assign the result to the `enet_default` object and display the result to the screen.**  

**Which tuning parameter combinations are considered to be the best?**  

**Is the best set of tuning parameters more consistent with Lasso or Ridge regression?**  

#### SOLUTION

The random seed is set for you for reproducibility.  

```{r, solution_04b}
set.seed(1234)
enet_default <- train( outcome ~ x3 * (x1*x2 + I(x1^2) + I(x2^2)),
                       data = df_caret,
                       method = 'glmnet',
                       metric = my_metric,
                       preProcess = c("center", "scale"),
                       trControl = my_ctrl)

enet_default

```
The final values used for the model were alpha = 1 and lambda = 0.00303919ï¼Œthen the model is more consistent with Ridge regression.

### 4c)

Create a custom tuning grid to further tune the elastic net `lambda` and `alpha` tuning parameters.  

**Create a tuning grid with the `expand.grid()` function which has two columns named `alpha` and `lambda`. The `alpha` variable should be evenly spaced between 0.1 and 1.0 by increments of 0.1. The `lambda` variable should have 25 evenly spaced values in the log-space between the minimum and maximum `lambda` values from the caret default tuning grid. Assign the tuning grid to the `enet_grid` object.**  

**How many tuning parameter combinations are you trying out? How many total models will be fit assuming the 10-fold with 3-repeat resampling approach?**  

*HINT*: The `seq()` function includes an argument `by` to specify the increment width.  

*HINT*: Do not convert the `expand.grid()` result to a dataframe or tibble.  

#### SOLUTION

```{r}
lambda_range <- exp(seq(log(min(enet_default$results$lambda)),
                        log(max(enet_default$results$lambda)),
                        length = 25))
enet_grid <- expand.grid(alpha = seq(0.1, 1, by = 0.1),
                         lambda = lambda_range)

nrow(enet_grid)
# Calculate total models fit
nrow(enet_grid) * 10 * 3
```
How many?  
There are 250 tuning parameter combinations and assuming the 5-fold with 3-repeat resampling approach, a total of 7500 models will be fit.

### 4d)

**Train, assess, and tune the elastic net model with the custom tuning grid and assign the result to the `enet_tune` object. You should specify the arguments to `caret::train()` consistent with your solution in Problem 4b), except you should also assign `enet_grid` to the `tuneGrid` argument.**  

**Do not print the result to the screen. Instead use the default plot method to visualize the resampling results. Assign the `xTrans` argument to `log` in the default plot method call. Use the `$bestTune` field to print the identified best tuning parameter values to the screen. Is the identified best elastic net model more similar to Lasso or Ridge regression?**  

#### SOLUTION

The random seed is set for you for reproducibility. You may add more code chunks if you like.  

```{r, solution_04d}
set.seed(1234)
enet_tune <- train(outcome ~ x3 * (x1*x2 + I(x1^2) + I(x2^2)), data = df_caret, method = "glmnet",
                   trControl = my_ctrl, tuneGrid = enet_grid, metric = my_metric,
                   preProcess = c('center', 'scale'))

plot(enet_tune, xTrans = log)
```
```{r}
enet_tune$bestTune
```


What do you think?  
If alpha is close to 0, then the model is more consistent with Lasso regression, while if alpha is close to 1, then the model is more consistent with Ridge regression.
The value of alpha is 0.9, so the identified best elastic net model more similar to Ridge regression.

### 4e)

**Print the coefficients to the screen for the tuned elastic net model. Which coefficients are non-zero? Has the model been converted to a simpler model?**  

#### SOLUTION

```{r, solution_04e}
coefficients <- coef(enet_tune$finalModel, s = enet_tune$bestTune$lambda, mode = "fraction", x = enet_tune$trainingData[, -ncol(enet_tune$trainingData)])
print(coefficients)
```

What do you think?  
The coefficients X1, X2,X1:X2, X3B:X1,X3B:I(X1^2),and X3B:I(X2^2) are zero. So the complex model doesn't have been converted to a simpler model.
### 4f)

Let's visualize the predictive trends of the event probability from the tuned elastic net model. The `predict()` function for `caret` trained classifiers is different from the operation of `predict()` for `glm()` trained objects. You made predictions from `caret` trained binary classifiers in the previous assignment. The `type` argument is different for `caret` trained objects compared to `glm()` trained objects.  

The first argument to `predict()` for `caret` trained objects is the `caret` trained model and the second object, `newdata`, is the new data set to make predictions with. Earlier in the semester in homework 03, you made predictions from `caret` trained binary classifiers. That assignment discussed that the optional third argument `type` dictated the "type" of prediction to make. Setting `type = 'prob'` instructs the `predict()` function to return the class predicted probabilities.  

**Complete the code chunk below. You must make predictions on the visualization grid, `viz_grid`, using the tuned elastic net model `enet_tune`. Instruct the `predict()` function to return the probabilities by setting `type = 'prob'`.**  

#### SOLUTION

```{r, solution_04f, eval=TRUE}
pred_viz_enet_probs <- predict( enet_tune, newdata = viz_grid, type = 'prob' )
```


### 4g)

The code chunk below is completed for you. The `pred_viz_enet_probs` dataframe is column binded to the `viz_grid` dataframe. The new object, `viz_enet_df`, provides the class predicted probabilities for each input combination in the visualization grid. A glimpse is printed to the screen. Please not the `eval` flag is set to `eval=FALSE` in the code chunk below. You must change `eval` to `eval=TRUE` in the chunk options to make sure the code chunk below runs when you knit the markdown.  

```{r, compile_enet_pred_obj, eval=TRUE}
viz_enet_df <- viz_grid %>% bind_cols(pred_viz_enet_probs)

viz_enet_df %>% glimpse()
```


The glimpse reveals that the `event` column stores the **predicted event probability**. You must visualize the predicted probability as a faceted raster plot just like you did in 3g). You must use the diverging palette to show the 50% decision boundary.  

**Visualize the predicted probability from the tuned elastic net model with respect to `x1` and `x2` using `geom_raster()` faceted by `x3`. You must use the same diverging palette as 3g).**  

*HINT*: The event probability was named `mu` when you made the previous figure in 3g). The event probability is now named `event`!  

#### SOLUTION

```{r}
viz_enet_df %>% 
  ggplot(mapping = aes(x = x1, y = x2)) +
  geom_raster(mapping = aes(fill = event)) +
  scale_fill_gradient2(low = 'blue', mid = 'white', high = 'red',
                       midpoint = 0.5,
                       limits = c(0, 1))+
   facet_wrap(~x3) 
```


### 4h)

**Create a plot to show the variable importance rankings associated with the tuned elastic net model. Are the importance rankings consistent with the visualization of the predicted probability?**  

*HINT*: You visualized variable importance rankings from `caret` trained models in HW09.  

#### SOLUTION
```{r}
enet_varimp <- varImp(enet_tune, scale = FALSE)
plot(enet_varimp)
```
The most important feature is the one with the highest variable importance measure, so I(X3^2) is the most important feature.The importance rankings consistent with the visualization of the predicted probability.


## Problem 05

The data in this assignment are not challenging. The point was to demonstrate that we can train **generalized linear models** with non-linear features to learn non-linear decision boundaries! We improved the performance by *manually* deriving the non-linear features.  

Modern machine learning applications also involve more advanced models that do not require us to manually derive the non-linear features. Instead, the models attempt to *learn* the non-linear relationships for us. Such models can be very accurate, however these advanced models are not as easy to interpret as generalized linear models. That is why it is critical to train generalized linear models before training any advanced method like neural networks, random forests, and gradient boosted trees.  

Even though this is a relatively simple application, let's train several advanced methods to compare to the tuned elastic net model. This will allow us to compare the performance and predictive trends of these more advanced models to simpler and easier to interpret models. This provides context for understanding why the more advanced models out perform the simpler ones!  

**Important**: Each of the advanced non-linear models attempt to learn *basis functions* for us. Thus, you will not specify polynomials, or natural splines, or any other function within the formula. Instead, you should type the formula in `caret::train()` as if you are using linear additive features. The non-linear models will "create" the non-linear features for you. The `df_caret` dataframe only consists of inputs, `x1` through `x3`, and the binary outcome, `outcome`. Thus you can use the `.` "shortcut" operator to define the formula for each non-linear model:  

`outcome ~ .`

This will save on typing **but** can only be used because the `df_caret` dataframe only contains the inputs and output. If there were other variables within the dataframe and we did not want to use then we could not use the `.` operator like that.  

### 5a)

You will begin by training a neural network via the `nnet` package. `caret` will prompt you to install `nnet` if you do not have it installed already. Please open the R Console to "see" the prompt messages to help with the installation.  

You will first use the default `caret` tuning grid for `nnet`. You will train a neural network to classify the binary outcome, `outcome`, with respect to the continuous and categorical input. As previously stated, you may use the `.` "shortcut" operator in the formula to `caret::train()` to say the output is a function of "everything else" in the dataframe. Assign the `method` argument to `'nnet'` and set the `metric` argument to `my_metric`. You must also instruct `caret` to standardize the features by setting the `preProcess` argument equal to `c('center', 'scale')`. Assign the `trControl` argument to the `my_ctrl` object.  

You are therefore using the same resampling scheme for the neural network as you did with the elastic net model! This will allow directly comparing the neural network performance to the elastic net model!  

**Train, assess, and tune the `nnet` neural network with the defined resampling scheme. Assign the result to the `nnet_default` object and print the result to the screen. Which tuning parameter combinations are considered to be the best?**  

**IMPORTANT**: include the argument `trace = FALSE` in the `caret::train()` function call. This will make sure the `nnet` package does **NOT** print the optimization iteration results to the screen.  

#### SOLUTIOn

The random seed is set for you for reproducibility. You may add more code chunks if you like.  

```{r, solution_05a}
set.seed(1234)
nnet_default <- train( outcome ~ .,
                       data = df_caret,
                       method = 'nnet',
                       metric = my_metric,
                       trControl = my_ctrl,
                       preProcess = c("center", "scale"),
                       trace = FALSE)

nnet_default
```

### 5b)

The default neural network tuning grid uses a small number of **hidden units** or *neurons*. This makes sure the default training time is relatively fast. Let's try several more complicated neural networks by adding more hidden units in the hidden layer!  

You must define a custom tuning grid for the neural network. This tuning grid has 2 tuning parameters, similar to the elastic net tuning grid. The first tuning parameter `size` is the number of hidden units in the hidden layer and the second tuning parameter is `decay`. The `decay` is the regularization strength of the **ridge** penalty. Thus, `nnet` is training ridge regularized neural networks!  

**Create a tuning grid with the `expand.grid()` function which has two columns named `size` and `decay`. The `size` variable have 4 unique values of 5, 9, 13, 17, and 21. The `decay` variable must be positive, but you will define its search grid in the log-space. You must apply the `exp()` function to 11 evenly spaced values between -6 and 0. Assign the tuning grid to the `nnet_grid` object.**  

**How many tuning parameter combinations will you try?**  

#### SOLUTION
```{r}
nnet_grid <- expand.grid(size = c(5, 9, 13, 17, 21),
                         decay = exp(seq(-6, 0, length = 11)))

nrow(nnet_grid)
```
There are 55 tuning parameter combinations.

### 5c)

**Train, assess, and tune the `nnet` neural network with the custom tuning grid and the defined resampling scheme. Assign the result to the `nnet_tune` object. You should specify the arguments to `caret::train()` consistent with your solution in Problem 5a), except you should also assign `nnet_grid` to the `tuneGrid` argument.**  

**Do not print the result to the screen. Instead use the default plot method to visualize the resampling results. Assign the `xTrans` argument to `log` in the default plot method call. Use the `$bestTune` field to print the identified best tuning parameter values to the screen. How many hidden units are associated with the best model?**  

**IMPORTANT**: include the argument `trace = FALSE` in the `caret::train()` function call. This will make sure the `nnet` package does **NOT** print the optimization iteration results to the screen.  

#### SOLUTIOn

The random seed is set for you for reproducibility. You may add more code chunks if you like.  

*PLEASE NOTE*: This code chunk may take several minutes to complete!  

```{r, solution_05c}
set.seed(1234)
nnet_tune <- train( outcome ~ .,
                    data = df_caret,
                    method = 'nnet',
                    metric = my_metric,
                    preProcess = c("center", "scale"),
                    tuneGrid = nnet_grid,
                    trControl = my_ctrl,
                    trace = FALSE)
plot(nnet_tune, xTrans = log)
```


```{r}
nnet_tune$bestTune
```
There are 17 hidden units associated with the best model.

### 5d)

Let's use predictions to examine the behavior of the neural network in greater detail. You will predict the same input visualization grid, `viz_grid`, as the previous models.  

**Complete the code chunk below. You must make predictions on the visualization grid, `viz_grid`, using the tuned neural network model `nnet_tune`. Instruct the `predict()` function to return the probabilities by setting `type = 'prob'`.**  

#### SOLUTION

```{r, solution_05d, eval=TRUE}
pred_viz_nnet_probs <- predict(nnet_tune, newdata = viz_grid, type = 'prob')
```

### 5e)

The code chunk below is completed for you. The `pred_viz_nnet_probs` dataframe is column binded to the `viz_grid` dataframe. The new object, `viz_nnet_df`, provides the class predicted probabilities for each input combination in the visualization grid according to the tuned neural network. A glimpse is printed to the screen. Please not the `eval` flag is set to `eval=FALSE` in the code chunk below. You must change `eval` to `eval=TRUE` in the chunk options to make sure the code chunk below runs when you knit the markdown.  

```{r, compile_nnet_pred_obj, eval=TRUE}
viz_nnet_df <- viz_grid %>% bind_cols(pred_viz_nnet_probs)

viz_nnet_df %>% glimpse()
```


The glimpse reveals that the `event` column stores the **predicted event probability**. You must visualize the predicted probability as a faceted raster plot just like you did in 3g). You must use the diverging palette to show the 50% decision boundary.  

**Visualize the predicted probability from the tuned neural network model with respect to `x1` and `x2` using `geom_raster()` faceted by `x3`. You must use the same diverging palette as 3g).**  

*HINT*: The event probability was named `mu` when you made the previous figure in 3g). The event probability is now named `event`!  

#### SOLUTION
```{r}
viz_nnet_df %>% 
  ggplot(mapping = aes(x = x1, y = x2)) +
  geom_raster(mapping = aes(fill = event)) +
  scale_fill_gradient2(low = 'blue', mid = 'white', high = 'red',
                       midpoint = 0.5,
                       limits = c(0, 1))+
 facet_wrap(~x3) 
```
  

### 5f)

The `caret` variable importance function can be applied to neural networks. It attempts to identify the most important inputs as viewed by the neural network.  

**Create a plot to show the variable importance rankings associated with the tuned neural network model. Are the importance rankings consistent with the rankings from the elastic net model?**  

*HINT*: You visualized variable importance rankings from `caret` trained models in HW09.  

#### SOLUTION
```{r}
nnet_varimp <- varImp(nnet_tune, scale = FALSE)
plot(nnet_varimp)
```
No, it's not the same.

### 5g)

**How does the neural network relate to the tuned elastic net model? Are the event probability predictions consistent? Are the importance inputs consistent?**  

#### SOLUTION

What do you think?  
The neural network and the elastic net model are both used for binary classification and have similar event probability predictions. However, the neural network and the elastic net model have different ways of creating features. The elastic net model uses parametric functions to define features, while the neural network creates features using simple rules, such as logistic regression models. Therefore, the elastic net model creates sharper decision boundaries than the neural network.

In terms of the importance of inputs, both the neural network and the elastic net model correctly identify that the continuous inputs are important. However, the elastic net model also considers quadratic features, which the neural network does not explicitly define.


## Problem 06

Let's now fit advanced tree based models. You will start with a random forest model. You will use the default tuning grid and thus do not need to specify `tuneGrid`. Tree based models do not have the same kind of preprocessing requirements as other models. Thus, you do not need the `preProcess` argument in the `caret::train()` function call. We will discuss why that is in lecture.  

### 6a)

**Train a random forest binary classifier by setting the `method` argument equal to `"rf"`. You must set `importance = TRUE` in the `caret::train()` function call. You may use the `.` "shortcut" operator to define the formula. Assign the result to the `rf_default` variable. Display the `rf_default` object to the screen.**  

**IMPORTANT**: `caret` will prompt you in the R Console to install the `randomForest` package if you do not have it. Follow the instructions.  

#### SOLUTION

The random seed is set for you for reproducibility. You may add more code chunks if you like.  

*PLEASE NOTE*: This code chunk may take several minutes to complete!  

```{r, solution_06a}
set.seed(1234)
rf_default <- train( outcome ~ .,
                     data = df_caret,
                     method = 'rf',
                     metric = my_metric,
                     trControl = my_ctrl,
                     importance = TRUE)

rf_default
```

### 6b)

Let's examine the random forest behavior through predictions.  

**Complete the code chunk below. You must make predictions on the visualization grid, `viz_grid`, using the random forest model `rf_default``. Instruct the `predict()` function to return the probabilities by setting `type = 'prob'`.**  

#### SOLUTION

```{r, solution_06b, eval=TRUE}
pred_viz_rf_probs <- predict(rf_default, newdata = viz_grid, type = 'prob')
```

### 6c)

The code chunk below is completed for you. The `pred_viz_rf_probs` dataframe is column binded to the `viz_grid` dataframe. The new object, `viz_rf_df`, provides the class predicted probabilities for each input combination in the visualization grid according to the random forest model. A glimpse is printed to the screen. Please not the `eval` flag is set to `eval=FALSE` in the code chunk below. You must change `eval` to `eval=TRUE` in the chunk options to make sure the code chunk below runs when you knit the markdown.  

```{r, compile_rf_pred_obj, eval=TRUE}
viz_rf_df <- viz_grid %>% bind_cols(pred_viz_rf_probs)

viz_rf_df %>% glimpse()
```


The glimpse reveals that the `event` column stores the **predicted event probability**. You must visualize the predicted probability as a faceted raster plot just like you did in 3g). You must use the diverging palette to show the 50% decision boundary.  

**Visualize the predicted probability from the random forest model with respect to `x1` and `x2` using `geom_raster()` faceted by `x3`. You must use the same diverging palette as 3g).**  

*HINT*: The event probability was named `mu` when you made the previous figure in 3g). The event probability is now named `event`!  

#### SOLUTION
```{r}
viz_rf_df %>% 
  ggplot(mapping = aes(x = x1, y = x2)) +
  geom_raster(mapping = aes(fill = event)) +
  facet_wrap(~x3) +
  scale_fill_gradient2(low = 'blue', mid = 'white', high = 'red',
                       midpoint = 0.5,
                       limits = c(0, 1))
```


### 6d)

You should have included `importance = TRUE` in the `caret::train()` call in 6a). This allows the random forest specific variable importance rankings to be returned.  

**Create a plot to show the variable importance rankings associated with the random forest model. Are the importance rankings consistent with the rankings from the elastic net model?**  

*HINT*: You visualized variable importance rankings from `caret` trained models in HW09.  

#### SOLUTION
```{r}
rf_varimp <- varImp(rf_default, scale = FALSE)
plot(rf_varimp)
```
The importance rankings doesn't consistent with the rankings from the elastic net model.

## Problem 07

Let's wrap up this modeling exercise by training a gradient boosted tree via XGBoost.  

### 7a)

You will begin by using the default tuning grid from `caret`.  

**Train a gradient boosted tree binary classifier via XGBoost by setting the `method` argument equal to `"xgbTree"`. You should NOT include `importance = TRUE` in the `caret::train()` function call. You may use the `.` "shortcut" operator to define the formula. Assign the result to the `xgb_default` variable.**  

**Do not display `xgb_default` to the screen. Instead, use the default plot method to plot the performance. You do not need to set any additional arguments to the default plot method.**  

**Display the best tuning parameters for the gradient boosted tree to the screen.**  

#### SOLUTION

The random seed is set for you for reproducibility. You may add more code chunks if you like.  

*PLEASE NOTE*: This code chunk may take several minutes to complete!  

**IMPORTANT**: include the argument `verbosity = 0` in the `caret::train()` function call. This will make sure the `xgBoost` package does **NOT** print a lot of warning messages to the screen. The warning messages result because the XGBoost package has included syntax changes in the most recent versions. The `caret` package uses older syntax which thus causes a large number of warning messages will be displayed to the screen.  

```{r, solution_07a}
set.seed(1234)
xgb_default <- train( outcome ~ .,
                      data = df_caret,
                      method = 'xgbTree',
                      metric = my_metric,
                      trControl = my_ctrl,
                      lverbose = FALSE,
                      verbosity = 0)
plot(xgb_default)
```
```{r}
xgb_default$bestTune
```


### 7b)

Let's make predictions with the gradient boosted tree like we did with the other models.  

**Complete the code chunk below. You must make predictions on the visualization grid, `viz_grid`, using the random forest model `xgb_default``. Instruct the `predict()` function to return the probabilities by setting `type = 'prob'`.**  

#### SOLUTION

```{r, solution_07b, eval=TRUE}
pred_viz_xgb_probs <- predict(xgb_default, newdata=viz_grid, type='prob')
```

### 7c)

The code chunk below is completed for you. The `pred_viz_xgb_probs` dataframe is column binded to the `viz_grid` dataframe. The new object, `viz_xgb_df`, provides the class predicted probabilities for each input combination in the visualization grid according to the random forest model. A glimpse is printed to the screen. Please not the `eval` flag is set to `eval=FALSE` in the code chunk below. You must change `eval` to `eval=TRUE` in the chunk options to make sure the code chunk below runs when you knit the markdown.  

```{r, compile_xgb_default_pred_obj, eval=TRUE}
viz_xgb_df <- viz_grid %>% bind_cols(pred_viz_xgb_probs)
viz_xgb_df %>% glimpse()
```


The glimpse reveals that the `event` column stores the **predicted event probability**. You must visualize the predicted probability as a faceted raster plot just like you did in 3g). You must use the diverging palette to show the 50% decision boundary.  

**Visualize the predicted probability from the XGBoost model with respect to `x1` and `x2` using `geom_raster()` faceted by `x3`. You must use the same diverging palette as 3g).**  

*HINT*: The event probability was named `mu` when you made the previous figure in 3g). The event probability is now named `event`!  

#### SOLUTION

```{r}
viz_xgb_df %>% 
  ggplot(mapping = aes(x = x1, y = x2)) +
  geom_raster(mapping = aes(fill = event)) +
  scale_fill_gradient2(low = 'blue', mid = 'white', high = 'red',
                       midpoint = 0.5,
                       limits = c(0, 1))+
   facet_wrap(~x3)
```


### 7d)

Gradient boosted trees also provide variable importance rankings.  

**Create a plot to show the variable importance rankings associated with the XGBoost model. Are the importance rankings consistent with the rankings from the elastic net model?**  

*HINT*: You visualized variable importance rankings from `caret` trained models in HW09.  

#### SOLUTION
```{r}
xgb_varimp <- varImp(xgb_default, scale = FALSE)
plot(xgb_varimp)
```


The importance rankings doesn't consistent with the rankings from the elastic net model.


### 7e)

You used the default XGBoost tuning grid. Let's see if we can improve the model further by using a refined tuning grid! This grid will focus on the most critical tuning parameters of the XGBoost model: the number of trees, `nrounds`, the interaction depth, `max_depth`, and the learning rate, `eta`. XGBoost has even more tuning parameters, but you will keep those fixed at values identified by the default tuning grid.  

The code chunk below is started for you. It defines a tuning grid via `expand.grid()` for all tuning parameters associated with XGBoost. You must complete the code chunk in order to define a tuning grid that focuses on the three most important parameters.  

**Complete the code chunk below. The number of trees, `nrounds`, should be a sequence from 25 to 50 in intervals of 25. The interaction depth, `max_depth`, should be a vector with values 3, 6, 9, and 129. The learning rate, `eta`, should be a vector with values equal to 0.25, 0.5, and 1 times the default grid's best `eta` value. All other tuning parameters should be set to constants equal to the identified best tuning parameter values from the default grid.**  

#### SOLUTION

```{r, solution_07e, eval=TRUE}
xgb_grid <- expand.grid(nrounds = c(25, 50),
                        max_depth = c(3, 6, 9, 129),
                        eta = c(0.25 * xgb_default$bestTune$eta, 0.5 * xgb_default$bestTune$eta, xgb_default$bestTune$eta),
                        gamma = xgb_default$bestTune$gamma,
                        colsample_bytree = xgb_default$bestTune$colsample_bytree,
                        min_child_weight = xgb_default$bestTune$min_child_weight,
                        subsample = xgb_default$bestTune$subsample)
```


### 7f)

**Train, assess, and tune the XGBoost model with the custom tuning grid and the defined resampling scheme. Assign the result to the `xgb_tune` object. You should specify the arguments to `caret::train()` consistent with your solution in Problem 7a), except you should also assign `xgb_grid` to the `tuneGrid` argument.**  

**Do not print the result to the screen. Instead use the default plot method to visualize the resampling results. Use the `$bestTune` field to print the identified best tuning parameter values to the screen. How many iterations or trees are associated with the best tuned model? What is the interaction depth associated with the best tuned model?**  

#### SOLUTIOn

The random seed is set for you for reproducibility. You may add more code chunks if you like.  

*PLEASE NOTE*: This code chunk may take several minutes to complete!  

**IMPORTANT**: include the argument `verbosity = 0` in the `caret::train()` function call. This will make sure the `xgBoost` package does **NOT** print a lot of warning messages to the screen. The warning messages result because the XGBoost package has included syntax changes in the most recent versions. The `caret` package uses older syntax which thus causes a large number of warning messages will be displayed to the screen.  

```{r, solution_07f}
set.seed(1234)
xgb_tune <- train(outcome ~ .,
                  data = df_caret,
                  method = "xgbTree", 
                  tuneGrid = xgb_grid, 
                  trControl = my_ctrl,
                  metric = my_metric,
                  lverbose = FALSE, 
                  verbosity = 0)
plot(xgb_tune)
```
```{r}
xgb_tune$bestTune
```

The best tuned model has 50 iterations or trees.
The interaction depth associated with the best tuned model is 3.



## Problem 08

Lastly, let's compare the various `caret` trained models based on our resampling scheme.  

### 8a)

**Complete the first code chunk below which compiles the tuned elastic net, default neural network, tuned neural network, default random forest, and default XGBoost models together.**  

**The field names in the list state which model should be assigned.**  

#### SOLUTION

```{r, solution_08a, eval=TRUE}
caret_acc_compare <- resamples(list(ENET_tune = enet_tune,
                                    NNET_default =nnet_default,
                                    NNET_tune = nnet_tune,
                                    RF = rf_default,
                                    XGB_default = xgb_default,
                                    XGB_tune = xgb_tune))
```


### 8b)

Visually compare the models based on the resampled Accuracy with a dotplot.  

**Use the `dotplot()` function to visualize the resampled performance summary for each model. Assign the `metric` argument to `'Accuracy'` to force the `dotplot()` function to only show Accuracy.**  

**Which model is the best for this application?**  

#### SOLUTION

```{r}
dotplot(caret_acc_compare, metric = 'Accuracy')
```
 
 
ENET_tune model is the best for this application

### 8c)

**How would you describe the differences between the 4 types of models you trained in this application?**  

#### SOLUTION

What do you think?  
In this project, we trained four different types of models to predict whether a credit card transaction is fraudulent or not. The models were Elastic Net, Random Forest, Neural Network, and XGBoost. Each model has its own strengths and weaknesses, and we used a variety of performance metrics to evaluate how well each model performed.

The dot plot shows the accuracy scores for each of the models. The higher the accuracy score, the better the model is at correctly predicting whether a transaction is fraudulent or not.

Based on the plot, we can see that the best model overall was the Elastic Net model with custom tuning. However, we can also see that the XGBoost models (both default and tuned) performed very well, and were very close in accuracy to the Elastic Net model. The Neural Network and Random Forest models performed relatively poorly in comparison to the other models.

Overall, the XGBoost and Elastic Net models outperformed the other models. XGBoost is a type of boosted tree model that can handle complex interactions between variables, while Elastic Net is a linear model that performs well in high-dimensional settings. Neural Networks and Random Forests are also popular models, but they may not always perform as well as XGBoost or Elastic Net depending on the specific dataset and problem.